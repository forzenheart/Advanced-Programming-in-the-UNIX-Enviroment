#include <stdio.h>

void
test(char **p)
{
	char a = 'a';/*在test()函数的栈帧上定义了一个局部变量a, 比把他的地址传给*p*/ 
	*p = &a;
}

void
constTest(char **p)/*注意此处是指针的指针，表示我们要修改的是地址本身而不是指针指向的内容*/ 
{
	char *a = "a";
	/*注意此处是双引号，代表是字符串常量，而不是字符，具体区别
	*还没弄清楚, 但是并不影响我们想表达的意思。
	*此时不在定义局部变量，而是定义了一个指针，这个指针指向的是字符串
	*常量的地址，这个地址在程序运行期间是固定的，所以即使退出函数，这个地址依然有效
	*所以此时打印地址上的内容会是正确的*/ 
	*p = a;
}
void
test2(char notUsingC) /*该函数用来重写test函数产生的栈帧*/ 
{
	/*如果函数栈帧数大小与第一个函数栈帧大小相同，那么此时打印地址c的内容会显示test2函数栈帧的内容*/
	/*注意此我们并没有直接使用c的地址，却同样修改了c地址指向的内容*/
	char temp = notUsingC;
}
int
main(void)
{
	char	*c;
	test(&c); 
	/*
	 *如果没调用test2函数的情况下，test的栈帧的数据还保留在该地址上，但是这是不确定的
	 *因此，如果在此时打印地址上的内容，就会正确显示地址上的内容，前提是没有其他函数
	 *的栈帧重写了此片地址，如果其他函数的栈帧重写了该地址的话，显示的内容就会出错
	 */
	printf("%c\n", *c); /* 此时由于test函数的栈帧上的内容并没有被修改，所以打印结果是a*/ 
	test2('b'); /*重写test（）函数的栈帧，使其地址内容被改;注意此处我们并没有使用c的地址*/
	printf("%c\n", *c); /*输入结果为b, 而不是a*/ 
	/*打印出错，如果第二个函数栈帧没有修改到test的内容就会正常显示, 否则此时打印的是
	 * 第二个函数的栈帧数上的内容, 前提是该程序只有这2个栈帧产生*/ 
	/*constTest(&c);*/
	/*printf("%c\n", *c);*/
	/*现在c指向的字符串常量的地址，是固定的，不能被修改的，所以不会出错*/
	return 0;
}

/*这个程序我是在ubuntu下进行测试的，在其他的系统尚未进行测试，其中的printf()函数的调用可能会重写test函数的栈帧；*/
/*所以建议使用gdb进行调试，而不要依赖于printf函数，在这里使用printf函数只是起到一个简单的展示作用;*/
